# make a webpack2

昨天看到使用库来得到 AST, 那么我们得到 AST 只是完成了解析 require 函数的这一步, 得到 AST 我们下一步该怎么做呢?
接下来应该是分析依赖, 分析依赖因为是 commonjs 规范, 所以应该是一个深度遍历算法.

那么这个算法的开始应该用一个对象存储起各个模块的信息, 然后还有模块与 id 的映射关系, 之前说到, 调用模块的时候一般是用 id 来代替名字的.

那么遍历模块肯定要查找模块的, 那怎么查找模块呢? 查找模块是查找模块的绝对路径的.
## 遍历分析依赖
本质上就是一个递归函数, 即深度遍历函数, 输入入口文件, 自动遍历.
首先需要初始化一个树数据, 记录全局的模块与模块依赖
```
var depTree = {
  modules: {},   //存储模块对象
  chunks: {},   //存储块
  mapModuleNameToId: {},  //储存模块名与 id 的映射
  modulesById: {}  //通过索引查找模块
}
```
然后将使用查找功能,得到入口文件的绝对路径, 使用绝对路径作为模块名:
```
module = depTree.modules[absolutePath] = {
  id: id++,
  filename: absolutePath,
  name: modulename  //模块名, 也就是 require 的时候的名字
}
```
通过库的解析和 fs 模块的查找, 将源文件与依赖记录在 module 的 resource 和 require 中.然后查看模块有没有依赖, 如果有依赖就遍历依赖, 继续查找模块.

## 查找模块
查找模块就要借助文件操作能力, node 就大派用场了, 利用 fs 模块和 path 模块.
先判断路径是不是绝对路径(或许还要自动为路径加上 .js 后缀), 这一步可以使用 path 的 path.isAbsolute 判断绝对路径和 path.extname 获取文件拓展名.
如果不是则判断是不是相对路径, 判断相对路径就看路径开头是不是 ./ 或者 ../ 这样的字符, 如果是则使用 path.resolve 来得到文件的绝对路径.
最后如果既不是绝对路径也不是相对路径那么就是一个单文件名, 这时候就需要一些自动查找算法了.
第一当然需要将入口文件所在目录的路径传进来, 然后逐渐去查找, 顺序是当前目录, 然后是当前目录的 node_modules, 然后也可以添加一些自己喜欢的文件路径比如 loader 等等的
文件夹.
分析好依赖之后, 将依赖信息放在 module 对象的 require 属性内.

得到依赖树的信息之后, 就可以拼接 bundle.js 了, 所谓拼接起就是再一次将得到的依赖树遍历一遍, 根据 id 的递增将模块代码打包到一个数组里面, 打包到 template.js 里面.
在拼接的时候需要注意的就是将模块名字替换成模块 id, 也就是遍历模块的 require, 然后将 require 中的模块逐个将名字转化为 id.
需要注意的是, 替换模块名字变 id, 需要从后面开始替换, 开始我也不理解是为什么, 但是我看到模块里面存储的 source 也就是模块源文件我就懂了, 其实库在解析的时候,会将匹配到的 token 的位置都记录下来, 而对于一个源文件来说, 其实都不存在换行符这样的东西的, 都是单行的, 这样其实非常方便, 我们这样就可以直接使用字符串替换, 根据位置准确替换, 从后面开始替换就是为了不让位置错乱, 因为字符增加记录的位置信息就不准确了, 从后面开始保证了位置信息准确.



