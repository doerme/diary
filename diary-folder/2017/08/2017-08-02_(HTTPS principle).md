# HTTPS principle

HTTPS 在目前大范围地使用，我觉得确实有好处，https 阻止了运营商 HTTP 劫持的这种恶心的推广
方式，而且网站如果使用了 HTTPS 那么可以考虑升级 http2， 这样对网站的性能是比较好的。
对比于HTTP, HTTPS 提供数据完整性校验， 身份验证， 数据加密。
但是也有缺点，由于 TSL 层的存在，服务器 CPU 的消耗更大了，因为需要使用非对称加密算法，服务器需要比较好的计算能力才能维持开销需要。

此外，我们在浏览器输入域名来访问网站的时候，是默认访问的是 http 协议的，我们当然可以在服务器设置一个重定向让网站定向到 https，但是这样用户的延迟就增大了，所以需要别的方法，我看到天猫的做法是添加一个头部：
```
Strict-Transport-Security: max-age=0
```
这样让网站强制浏览器使用 https 与服务器进行连接，这样一方面不必重定向另一方面就是更加安全，
因为如果我们使用了 302 重定向，有可能有中间人篡改劫持。

那么 https 的具体过程是怎么样的呢？也就是说 HTTPS 的工作原理

TLS 的四次握手过程。TLS 是属于应用层协议.
1. 明文方式下，客户端生成一个随机数，和支持的加密方式列表发送到服务端
2. 明文方式下， 服务端生成一个随机数，和选择的加密方式和证书链发送到客户端
3. 客户端验证服务器证书，使用证书中的公钥加密根据内容 hash 生成的一个随机字符串，发送到服务端
4. 服务端使用私钥解密生成的随机字符串，使用客户端生成的随机数，服务端生成的随机数，和刚刚解密的字符串生成一个密钥，使用这个密钥来加密后续的通信内容。

证书是什么，为什么需要证书，怎么验证证书的正确性？
证书包含所有者姓名，所有者公钥，过期时间和序列号，因为太多设备和服务器需要验证其身份，客户端不可能存储全部证书，所以需要服务端发送。
验证证书是为了不让中间人伪造证书，验证证书通过数字签名，也就是通过内容 hash 取得信息摘要然后使用公钥加密得到数字签名。
公钥和消息一样不能明文传输，所以需要第三方机制来保证安全，也就是 CA 证书机构, 某个端会使用 CA 证书上的公钥进行解密验证。
所谓证书链就是 Bob -> CA -> Ada, 证书就是一对公钥和私钥，公钥是锁头，私钥是钥匙，用锁头将内容锁起来，全世界只有一把钥匙。

TSL 协议包括握手，record， 有四个子协议运行在 record 上，像握手，alert， change cipher spec，application data。
record 会对数据进行加密解密

内容使用对称加密是因为性能的问题。

而且在 ssl 中，如果连接突然中断，ssl 会有一个 session id 或者是 session ticket 来重连连接， 而且当客户端再次访问的时候只需要给出 id 或者 ticket 就可以使用
密钥不需要在生成一次。

## Tips
TCP 的三次握手与四次挥手.
TCP 三次握手, 客户端发送一个 SYN 建立链接, 进入 SYN_SEND 状态, 服务端发送一个 SYN ACK, 代表服务端确认请求有效, 进入 SYN_RECV 状态, 然后客户端收到 SYN ACK, 发送一个 ACK + SYN
给服务端, 两端都进入 established 状态.
TCP 会话序列号从 0 开始, 确认号会加 1, 两个端都有序列号和确认号, 序列号是表示当前端成功发送了的数据长度, 确认号是表示当前端成功接收了的数据长度.SYN / FIN 标志位也要占一位.

为什么是 3 次握手?
因为第一次握手是为了通知服务端建立链接通道, 第二次握手是服务端通知客户端请求有效, 可以建立链接, 第三次握手是客户端再次确认请求建立, 这个时候服务端才建立起通道, 如果是只有两次的话, 在
第二次握手之后客户端突然中断了请求, 那么服务端建立的通道就会长时间挂在那里, 浪费资源了.

四次挥手?
1. A 端发送一个 FIN 包过去给 B 端, 表示当前端(A)没有数据需要发送给对方(B)了, 然后进入 FIN_WAIT1 状态, 
2. 然后对方端(B)接收 FIN, 给 A 端发送一个 FIN ACK 包, 表示 B 已经知道了 A 没有
数据需要发送了, A 接收到 FIN ACK 之后变为 FIN_WAIT2 , 
3. 但是虽然 B 端已经允许了关闭端口, 但是 B 端可能还在发送数据当中或者数据还没有发送完, 需要等待这部分数据发送完, 发送完数据之后, 
B 端也没有数据需要发送给 A 端了, 所以会向 A 端发送一个 FIN 包, 表示 B 端没有数据需要发送了(数据已经发送完了), 然后进入 CLOSE_WAIT, 
4. A 端接收到 B 端的 FIN 包, 向 B 端发送一个 FIN ACK, 表示关闭确认, 然后 B 端接收到 FIN ACK 之后就关闭了端口, A 端在等待 2MASL(2个报文最大生存时间)之后, 认为
B 端已经接收到 FIN ACK 包并关闭端口了, 然后关闭了 A 端链接.两端进入 close.
为什么是四次挥手?
因为 TCP 是全双工通信, 两个端需要分别关闭端口, 另外, 在 A 端请求关闭端口的时候, B 端可能还在发送数据, 需要等待这部分数据发送完毕, 就像 "我知道要关闭端口了, 但是要等数据发送完", "我的
数据已经发送完了, 你可以关闭端口了".
A 端等待 2MASL 是因为可能需要重传 ACK.


links：

http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html

https://cattail.me/tech/2015/11/30/how-https-works.html

http://robertheaton.com/2014/03/27/how-does-https-actually-work/


