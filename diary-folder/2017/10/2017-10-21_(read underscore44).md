# front model

之前就发现了前端很少写 model, 前端 model 和后端的 model 是相通的, 都是定义数据格式.但是前端的 model 更多地是用来存储数据, 而不是定义数据集.
但是根据最近的反思, 即使后端给了接口的数据源, 这个是无法避免的, 这个是最上游的数据, 但是是不是就代表数据的粒度没办法改变了呢?
后端接口有时候会粒度非常细, 单页面可能接口非常多, 这个问题有人说可以用 nodejs 做中间层做数据整合, 我觉得这个其实不能解决问题, 只是将问题延后了, 
个人觉得这个问题需要规定一个 API 平台, 由前后端一起规定这个 API, 不能由前端说了算, 也不能由后端说了算, 这样能够最大程度地解决问题.
虽然 node 做中间层做数据整合会让页面只需访问一个接口, 加载速度提升, 但是开发效率有点低, 如果多页之间的复杂度上来了就没啥用了.
除了这个, 还有接口顺序问题, 就是接口往往需要按顺序来调用的, 这个问题可以用 promise.then, promise.all 来实现, 但是我觉得最好还是封装一个自己的函数来说这个
通用性的操作, 比如链接两个异步请求的操作.
像 redux, vuex 这样的就是用来解决前端数据不可复用的问题的, 全局存储, 不同页面共用数据, 这样非常方便.而且还可以借用 cookie 和 localstorage 来做核心数据持久话.
其实在用 mutation 的时候大可不必这么拘谨, mutation 是唯一可以改变 state 的方法, 可以利用 mutation 来将粒度进行加工, 如果接口的粒度没法控制的话, 
那么利用 mutation 来控制还是可以的, 而且他是同步的, 所以非常适合, 比如两个接口一个是获取用户 id, 一个是获取用户昵称等等, 后一个依赖于前一个, 但是利用 mutation 可以
将两者结合然后暴露出去保持纯净.
对于数据复用需要利用 mutation 和 formatter, 将数据转换格式.
对于 view 我一向的观点就是保持纯净, 只需展示, 不参与任何业务逻辑与展示逻辑. 为了 view 的复用需要做几点, 第一页面级别的组件才会链接到 state, store 等等.
第二 components 是业务组件, 只能用 props 获取数据, 保持复用性, 第三 UI 组件, 这部分放在另一个文件夹或者 npm 包内.
举个例子: 榜单有很多个榜, MVP, 好友等等, 可以终归属于 list 组件(业务组件, 放在 components), 但是从页面上来说, 可能这几个榜都属于在一个页面, 所以在比如 app.vue 这样的
页面级的才需要链接 store, 然后将数据传到 list.vue. 然后 tabs 滑动属于 UI 组件, 与业务无关, 所以可以用插件(npm)或者自己开发放在另一个文件夹内.