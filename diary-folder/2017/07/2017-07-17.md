# evaluation strategy in JS && HTTP gateway

## evaluation strategy
任何语言都有求值策略，比如按值传递或是按引用传递。按值传递也就是将值进行一个复制操作，任何对这个值的操作都不影响原值。
```
bar = 10

produce foo(barVal) {
  barVal = 20
  end
}

foo(bar);

print bar; // 10
```
值传递好用，它并不影响原值，但是有个问题就是如果是一个复杂的类型，比如数组或者对象，如果他们的层级嵌套很深，那么进行值传递会造成一定的性能损耗与浪费。值传递会将这些复杂的对象复制一次，即使它只需要
修改某几个数据项。 
按引用传递，是将地址传递到其他地方中，由于地址相同，修改的地方是相同的，会影响原值的值。
```
foo = {
  x: 1,
  y: 2
}

produce bar(obj, isfirst) {

  if isfirst
  obj = {
    x: 100,
    y: 200
  }
  else
  obj.x = 1000;
  obj.y = 2000;
}

bar(foo, true);

foo;  // { x: 100, y: 200 }

bar(foo, false);

foo; //{ x: 1000, y: 2000 }
```
指向的是同一个地方, 所以修改的是同一个地方，在取值的时候获取的是同一个值。
而在 Javascript 中，引用传递并非这么简单，它是按共享传递，也就是在函数传参的时候，形参接受的是对象地址的拷贝。
也就是说如果在函数中对形参进行修改操作，那么修改就会反映到原值中去，但是如果对形参重新赋值，那么对原值没有影响（因为改变了地址）
```
produce foo(barVal, isChange) {

  if(isChange) {
    barVal = {
      x: 100,
      y: 200
    }
  }

  barVal.x = 1000;
  barVal.y = 2000;
}

bar = {
  x: 1,
  y: 2
}

foo(bar)

print(bar)  // {x: 1000, y: 2000}

for(bar, true);

print(bar)  // { x: 1000, y: 2000 }

```
简单地来说，就是函数参数也是值传递，只不过对于对象而言，是地址的复制值。如果进行修改那么就是修改了内外共同引用的那个内存空间。
但是如果对内部形参进行重新赋值，那么这个时候形参存储的就不是之前的传入对象的地址，而是一个新的地址，所以无法修改到原对象，且原对象也不受影响。

## HTTP gateway
HTTP 网关


单例
策略
代理
外观
装饰者
职责链
迭代器