# Node.js web server && this

## how to develop a web server in NodeJs

## this
this 是一个指针，它并不是一个变量，所以它无法被赋值， 也就是在进入了函数的执行上下文无法被改变，它是执行上下文的属性。
在《you don't know js》中有提及 this 的四个指向的问题，第一就是如果使用 new 命令，那么 this 的值就是新构造的对象，第二就是硬绑定之类的方法传入的值，例如 call， apply， bind 等等的这些方法，如果函数使用这种方法来调用，那么 this 值就是 call、apply、bind 方法传入的第一个参数。对于软绑定与隐性丢失的问题，书中的阐述并不是太好，我觉得汤姆说的才比较清晰明了。也就是说在全局对象中的this 值与在函数中的 this 值有不同。全局代码中 this 值指向全局对象
```
var a = 1;
this.b = 2;
console.log(a);
console.log(this.a);
console.log(b);
```
而对于在函数中的 this， 它是根据调用的上下文（父级）来决定值的。
想要清楚函数调用中的 this 指向，除了要调整思想去知道这个函数是怎么来的以及怎么调用的（而不是想 this 的值是什么）之外，关键在于知道 js 中的引用类型。
引用类型有两种，也就是有两种情况，一个是我们处理标识符，另一个是我们处理属性访问器。
引用类型：
```
var foo = function(){};

bar.baz

Referrence {
  base: global,
  propertyName: 'foo'
}

Reference {
  base: bar,
  propertyName: 'baz'
}
```
而对于 this 来说，base 值就是至关重要的。
如果想要得到引用类型的值， 需要调用 [[GetValue]],
```
function GetValue(value){
  
  if(type(value) !== reference) {

    return;
  }

  var base = getBase(value);

  if(value === null) {

    throw new ReferenceError;
  }

  return base.[[get]](GetPropertyName(value))
}
```
从上面的伪代码可以看到，对于引用类型的取值，会先取 base， 然后在 base 基础上调取相对应属性名的值。
[[Get]] 方法会分析原型链上的变量值。

那么在函数调用的时候，this 由调用者决定，如果有 base 则为 base， 无则设为 null、undefined（ECMA5 为 undefined）。
举例子：
```
var foo = function(){
  console.log(this);
}

foo();

```
foo 是一个标识符， 那么看这个标识符的引用类型：
Reference {
  base: global,
  PropertyName: foo
}
所以打印出来是 global


```
var foo = {
  bar: function(){
    console.log(this);
  }
}

foo.bar();
```
看上面的例子：foo.bar 函数调用，那么左边的是对象属性访问器
Reference {
  base: foo,
  propertyName: 'bar'
}
所以打印出来是 foo


```
var test = foo.bar;
test();
```
这个例子， test 被赋值，值为 foo.bar 这个函数，那么看函数调用的时候， 函数左边的标识符：
Reference {
  base: global,
  propertyName: "test"
}

所以打印出来的是 global.

一个经典的例子：
```
function foo(){
  console.log(this);
}

console.log(foo === foo.prototype.constructor); //true

foo(); //global

foo.prototype.constructor(); // foo.prototype

Reference {
  base: foo.prototype,
  propertyName: 'constructor'
}
```
对于赋值、逻辑等操作符得到的不是引用类型， 而是函数对象：
(foo.base)(); //foo
(foo.base = foo.base)(); //global
(foo.base, foo.base)(); //global
(false || foo.base)(); //global

因为赋值、逻辑操作符得到的是函数对象了。