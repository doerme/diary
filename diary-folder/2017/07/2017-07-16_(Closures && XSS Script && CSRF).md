# Closures && XSS Script && CSRF

## Closures
闭包与 ECMASCript 中高阶函数, 函数式返回值, 函数式参数关系密切, 严格来说, ECMASCript 所有函数都是闭包, 因为函数在创建的时候就已经保留了对上一层父执行上下文的变量对象的引用, 也就是 [[scope]] 属性, 闭包的上层作用域的数据是通过动态分配,也就是堆来存储的, 而不是栈. 闭包引用了自由变量, 所谓自由变量就是既不是函数的局部变量也不是函数参数. 下面这个例子就是引用了自由变量:
```
var test = 'foo';

function bar(){
  console.log(test);
}

bar();
```
并且在同一个父级执行上下文创建的闭包共享一个 [[scope]], 这也解释了为什么在 for 循环中无法取到独立的下标值, 因为函数共享一个 [[scope]], 当循环结束, [[scope]]中的变量下标 i 已经变为了循环最后一次的值, 所以直接使用函数会打印错误, 如果想不一样的下标值就需要在不同的执行上下文中创建函数.
理论上是以上, 但是在实践中我们有没有必要将所有函数都称为闭包? 我们会将引用了自由变量或者在父级上下文已经撤销的情况下仍然保留函数(return function)的情况称为闭包.
在实践中, 闭包常用于回调(事件监听, setTimeout, Ajax 调用)与封装模块模式.

## XSS Script
深入讲一下 XSS , XSS 分为三种: 反射型, 存储型, DOM 型, 其中反射型是利用脚本中的漏洞, 在 url 中注入 XSS 恶意代码, 服务器没有经过验证直接发送给其他客户端形成攻击, 而对于存储型与反射型很像, 它则是将 XSS 代码存储在数据库中, 所有用户访问这个数据就会形成攻击, 经典例子就是文本框的输入.
以上两种都是主要在服务端做的一些防御工作, 对于 DOM 类型的 XSS 攻击, 就需要前端掌握了. DOM 类型就是利用客户端 js 脚本的漏洞(输入点, 例如 location cookie 等等)直接在客户端插入恶意件本(document.write 等等).
XSS 可以通过在标签的属性或者一个事件中触发, 比如可以通过 " ' 单引号双引号来闭合前一个属性, 然后添加一个事件
```
<img alt="" />
=> value = " onerror="alert(1)"
<img alt="" onerror="alert(1)"/> 
```
可以通过 < > 来闭合标签,然后插入一些像 img script 这样标签, 这些标签的 src 属性可以跨域请求文件,从而形成攻击.

总体来说, XSS 等的一些 web 攻击是离不开输入的, 而所谓输入不仅仅是页面中的 input 等输入框,还有浏览器导航栏也是可以植入的. 如果我们需要取 url 中的 hash 片段或者查询字符串等等, 然后将这个值输出到页面中, 那么如果不做 XSS 过滤, 有可能被 XSS 攻击.
如果是 HTML 标签之间的, 那么就有可能被插入一些类似 img , script 之类的 DOM 元素形成攻击, 但是如果是像 title, textarea, iframe 之类的标签之间就没用, 因为这些标签之间是不允许插入其他标签的.

而对于 DOM 类型的 XSS 攻击, 要理解在 HTML 中的转码机制. 如果是在 HTML 标签中的注入, 分为 HTML 标签之间与之内, 所谓之间是指 <div>....</div> 这样的形式, 所谓之内是指在 html 标签的属性中.一般来说像标签的 src/href, on* 事件, style 属性内都是可以发生注入的.
我们日常的需要会有需要将用户的输入输出到页面中, 但是如果是 html 中写的代码, 比如
```
<img onsucess="document.write('<img src="" onerror="alert('xss')" />')">
```
这样是会自动解码的, 这就是我们在使用一些 icon 时的原理, 但是这样会导致 xss 攻击, 上面的代码会造成攻击, 因为自动解码的存在, 它和下面这个是一样的
```
<img onsucess="document.write('&lt;img src=&slsfa&adsd onerror=&ltalert(&ltxss&lt)')">
```
所以我们在将一些特殊字符转码需要将 < > ' " & / 这几个都进行转码, 上面的代码如果需要防御则编写函数将刚说到的几个字符转码. 在 HTML 中的自动解码规则与 javascript 中的解码规则不同,
html 中的解码规则是十进制, 十六进制, 和上面的转码, 而 Javascript 中的是 unicode 形式, 十六进制, 纯转义(\'), 所以需要在不同环境做不同的转码过滤.

最近打算自己写一个 XSS 过滤脚本.
## CSRF
使用 refer 检查, document.referrer 无法通过 javascript 来伪造, 使用一次性 token, 检查同源, 限制 session cookie 的生命周期.
但是 token 时效性不好, 另外如果对于大型应用, 还需要一台服务器来生成和验证 token.