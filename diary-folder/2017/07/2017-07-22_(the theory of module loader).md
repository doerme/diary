# the theory of module loader

我们用过很多模块加载器, 像 seajs, requirejs 等等, 我之前项目里面就使用过 seajs.,但是他们的原理是什么呢?

其实他们的原理就是
第一步就是分析依赖, 分析入口文件的依赖模块是什么, 将依赖模块的路径保存下来. 

第二异步加载模块, 说到异步加载, 当然需要使用 XHR 通过上一步保存的路径来加载异步的 js 模块, 也就是一个个 js 文件.这个部分需要特别注意的就是跨域的问题, 但是这个问题可以通过 jsonp 来解决, 通过 jsonp 请求, 调取了模块, 拿到的模块里面的文件内容, 就开始下面的分析依赖, 因为加载的模块里面有可能另外依赖了其他模块.
并且将模块的代码缓存起来, 我之前在项目中使用 seajs 就发现需要对浏览器进行强制刷新操作, 才能刷新模块代码.

第三就是分析依赖, 因为依赖模块里面肯定会有重复的依赖模块, 甚至可能会遇到循环依赖, 那么这种情况, 作为一个模块加载器肯定需要优化这部分的加载性能的问题, 严重地需要解决循环依赖导致模块无法执行的问题.举个例子:
```
//a.js
var module = require('b.js');

//b.js
var module = require('a.js');
```
因为上一个模块需要再依赖的模块加载执行后才执行(因为依赖于模块的对象, 变量等等的), 但是因为循环依赖的存在, a 模块因为 b 模块无法加载完成而无法执行接下来的代码, 但是 b 模块的加载完成需要先加载 a 模块, 所以两个模块相互阻塞.
那说回开头, 怎么分析呢? 主要是通过正则表达式, 匹配指定的类似 require 这样的字符串, 得到第一层依赖, 然后进行循环分析, 分析出模块的层层依赖.然后再回到异步加载模块去, 周而复始.

一般来说, 会通过一个表(或者说 hash 对象)来记录依赖的情况, 当所有依赖全部加载完了, 通过一个事件告诉全局所有依赖模块全部加载完成了.

接下来, 对于模块, 肯定不希望污染全局对象, 所以会将模块封装在一个模块里面, 所以像 amd, cmd, commonjs 这样的, 都会提供一个暴露接口与加载接口, 上面所说的就是原理, 至于细节就是实现符合规范的接口了, 这是非常大的工程量.





